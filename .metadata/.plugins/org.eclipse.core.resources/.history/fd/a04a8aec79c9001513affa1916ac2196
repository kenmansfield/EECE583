/*
 * Assignment2.cpp
 *
 *  Created on: Jan 31, 2016
 *      Author: km
 */
#include <iostream>
#include <fstream>
#include <stdio.h>
#include <vector>
#include <unistd.h>
#include "graphics.h"
#include <string>
#include <sstream>
#include <algorithm>
#include "Assignment2.hpp"
#include <cassert>
#include <cmath>

using namespace std;

vector<Cell> sCells;
int ** sBoard = NULL;
vector< vector<int> > vNetFile;

float sBoxDim = 0;
static const int WIDTH = 1000;
float TOP_BORDER = 60;

int sNumCells = 0;
int sNumConnection = 0;
int sNumRows = 0;
int sNumColumns = 0;

//These are modifiers based on the different modes selected by the user.
static float sDelayModifier = 1.0f;
static bool sNoAnimation = false;
static bool sfinalAnimation = true;

bool ReadNetFile(string fileName)
{
    ifstream infile;
    infile.open(fileName.c_str());
    int lineNumber = 0;

    std::string line;

    if(!infile.is_open())
    {
        return 0;
    }

    int i = 0;
    while( getline(infile, line) )
    {
    	vector<int> tempVec;
        istringstream lineStream(line);
        int x;
        while(lineStream >> x)
        {
        	tempVec.push_back(x);
        }
        vNetFile.push_back(tempVec);
        i++;
    }
//    cout << "hello world!!\n";
//
//    for(int i = 0; i < vNetFile.size(); i++)
//    {
//    	for(int j = 0; j < vNetFile.at(i).size(); j++)
//    	{
//    		cout << vNetFile.at(i).at(j) << " ";
//    	}
//
//    	cout << endl;
//
//    }
    return ParseNetFile();
}

bool ParseNetFile()
{
	sNumCells = vNetFile.at(0).at(0);
	sNumConnection = vNetFile.at(0).at(1);
	sNumRows = vNetFile.at(0).at(2);
	sNumColumns = vNetFile.at(0).at(3);

	//Removing the first line, so that our vector is now just nets.
	vNetFile.erase(vNetFile.begin());
	assert(vNetFile.size() - 1 == sNumConnection);
}

void DrawGrid()
{
	int boxSize;

	setlinestyle (SOLID);
	setlinewidth (1);
	setcolor (BLACK);

	sBoxDim = WIDTH/(sNumRows * 2 + 1);

	for(int i = 0; i < sNumColumns; i++)
	{
		for(int j = 0; j < sNumRows; j++)
		{
			ColourRect(Point(i,j));
		}
		flushinput();
	}
	Point x;
}

void DrawNumbers(Point p, int x)
{
    char buff[10];
    sprintf(buff, "%i", x);
    string s(buff);
    setTextFill(p, s, BLACK);
    flushinput();
}

void setTextFill(Point p, string text, int color)
{
    if(sNoAnimation)
    {
        return;
    }

	//I think this is the top left, so need to offset it to the centre. And also make sure the font size is suitable.
	Vertice v = GetLocationToDraw(p);

	//The font doesn't allow for justify centre so we need a way of calculating the width of the font.
	//6 point font is approximately 8 pixels wide.
	float font_width = 8/2;
	float font_height = sBoxDim/2;

	//looks like it is justified centre, so don't need this
	float font_offset = 0;//font_width * text.length();

	float offset = sBoxDim/2 - font_offset;
    setcolor(color);
    drawtext(v.x + offset, v.y + font_height, const_cast<char*>(text.c_str()), 100);
    //flushinput();
}

Point GetLocation(Point p)
{
	//There is one space between each row for the routing.
	int yOffset = (int(p.y - 1));
	int posY = (p.y) + yOffset;
	int posX = p.x;

	Point location(posX, posY);
	return location;
}

Vertice GetLocationToDraw(Point P)
{
	Point tempPoint = GetLocation(P);
	return Vertice(sBoxDim * float(tempPoint.x), sBoxDim * float(tempPoint.y)  + TOP_BORDER);
}

void ColourRect(Point x)
{
	setlinestyle (SOLID);
	setlinewidth (1);
	setcolor (BLACK);

	Vertice v = GetLocationToDraw(x);
	float offset = sBoxDim/2;
	drawrect (v.x, v.y, v.x + sBoxDim, v.y + sBoxDim);
}

void InitGraphics()
{
	init_graphics("Lee-Moore Routing");

    //clearscreen();
    update_message("Simulated Annealing.");
    setcolor (RED);
    setlinewidth(1);
    init_world (0.,0.,WIDTH,WIDTH);
	setfontsize (8);
}

void Delay(int time)
{
    //convert from milliseconds to useconds
    if(sDelayModifier == 0)
    {
        return;
    }
    usleep(time * 1000 * sDelayModifier);
}

void InitBoard()
{
	//Initialize our empty board.
	sBoard = new int*[sNumColumns];
	for(int i = 0; i < sNumColumns; i++)
	{
		sBoard[i] = new int[sNumRows];
		for(int x = 0; x < sNumRows; x++)
		{
			sBoard[i][x] = -1;
		}
	}

	//Place each cell on the board and initialize our cells vector
	sCells.clear();
	sCells.resize(sNumCells);

	//cout << "\nwe have this many cells: " << sNumCells << "   thats it   -  ";
	for(int i = 0; i < sNumCells; i++)
	{
		int x = i % sNumColumns;
		int y = i / sNumColumns;
		sBoard[x][y] = i;

		//Initialize the current position of each cell
		sCells[i].p = Point(x,y);

		//And Draw!
		//cout << i << " ";
		DrawNumbers(Point(x,y), i);
	}

	for(int i = 0; i < vNetFile.size(); i++)
	{
		for(int j = 0; j < vNetFile[i].size(); j++)
		{
			int x = vNetFile[i][j];
			if (find(sCells[x].Nets.begin(), sCells[x].Nets.end(), i) == sCells[x].Nets.end())
			{
			  // only insert unique. just in case.
				sCells[x].Nets.push_back(i);
			}
		}
	}
}

void SwapCells(int cell1, int cell2, Point point1, Point point2)
{
	if(cell1 != -1)
	{
		sCells[cell1].p = point2;
	}
	if(cell2 != -1)
	{
		sCells[cell2].p = point1;
	}

	sBoard[temp1.x][temp1.y] = cell2;
	sBoard[temp2.x][temp2.y] = cell1;
}

void DoAnnealing()
{
	//start temperature.
	float Temperature = 60;
	float startCost = CostOfAllNets();

	//trying greedy first
	cout << "The start total is: " << startCost << endl;

	for(int i = 0; i < 2000; i++)
	{
		//pick two random cells.
		Point p1 = GetRandomPoint();
		Point p2 = GetRandomPoint();

		int cell1 = sBoard[p1.x][p1.y];
		int cell2 = sBoard[p2.x][p2.y];

		float cost1 = CostOfCell(cell1) + CostOfCell(cell2);

		//now do swap
		SwapCells(cell1, cell2, p1, p2);

		float cost2 = CostOfCell(cell1) + CostOfCell(cell2);

		//cost has gotten worse.
		if(cost2 > cost1)
		{
			SwapCells(cell1, cell2);
		}
		//Now decide whether to take the change or not. if not, then swap back and continue.

	}
	cout << "The total is: " << startCost << endl;
	//float r = rand();
	//float exponent = exp(r);
}

Point GetRandomPoint()
{
	int r = rand();
	int randNumber = r % (sNumColumns * sNumRows);
	int x = randNumber % sNumColumns;
	int y = randNumber / sNumColumns;
	return Point(x,y);
}

float CostOfAllNets()
{
	int total = 0;
	for(int i = 0; i < vNetFile.size(); i++)
	{
		total += CostOfNet(i);
	}
	return total;
}

float CostOfNet(int net)
{
	//Bounding box means getting the biggest and smallest X and Y.
	int size = vNetFile[net].size();
	int minX = 0;
	int minY = 0;
	int maxX = 0;
	int maxY = 0;

	if(size > 0)
	{
		int x = vNetFile[net][0];
		Point loc = GetLocation(sCells[x].p);

		minX = loc.x;
		minY = loc.y;
		maxX = minX;
		maxY = minY;
	}

	for(int i = 1; i < vNetFile[net].size(); i++)
	{
		int x = vNetFile[net][i];
		Point loc = GetLocation(sCells[x].p);
		maxX = max(loc.x, maxX);
		maxY = max(loc.y, maxY);
		minX = min(loc.x, minX);
		minY = min(loc.y, minY);
	}

	return CostOfPoints(Point(minX, minY), Point(maxX, maxY));
}

float CostOfPoints(Point locA, Point locB)
{
	float cost = abs(locA.x - locB.x) + abs(locA.y - locB.y);
	return cost;
}

float CostOfCell(int cellA)
{
	int netCost = 0;
	if(cellA >= 0 && cellA < sNumCells)
	{
		for(int i = 0; i < sCells[cellA].Nets.size(); i++)
		{
			netCost += CostOfNet(sCells[cellA].Nets[i]);
		}
	}
	return netCost;
}

int main (int argc, char *argv[])
{
	string FileName = "alu2.txt";
	ReadNetFile(FileName);
	InitGraphics();
	DrawGrid();
	InitBoard();
	DoAnnealing();

    while(true) {Delay(1000);}
}

